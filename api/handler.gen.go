// Code generated by protoc-gen-gotemplate
package wikibookgen

import (
	"context"
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	log "github.com/sirupsen/logrus"

	. "github.com/proullon/wikibookgen/api/model"
)

var _router *mux.Router

type Router struct {
	r *mux.Router
}

func (r *Router) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	if origin := req.Header.Get("Origin"); origin != "" {
		rw.Header().Set("Access-Control-Allow-Origin", origin)
		rw.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
		rw.Header().Set("Access-Control-Allow-Headers",
			"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
	}
	// Stop here if its Preflighted OPTIONS request
	if req.Method == "OPTIONS" {
		return
	}
	// Lets Gorilla work
	r.r.ServeHTTP(rw, req)
}

func init() {
	_router = mux.NewRouter().StrictSlash(true)
}

func Handle(method string, path string, handler http.Handler) {
	_router.Handle(path, handler).Methods(method)
	log.Printf("%-5s %s", method, path)
}

func HandleFunc(method string, path string, f func(http.ResponseWriter, *http.Request)) {
	_router.HandleFunc(path, f).Methods(method)
	log.Printf("%-5s %s", method, path)
}

func ListenAndServe(ctx context.Context, port string) error {
	var decoder httpDecoder

	HandleFunc("GET", strings.Split("/status", "?")[0], wrapstatus(ctx, decoder))
	HandleFunc("POST", strings.Split("/complete", "?")[0], wrapcomplete(ctx, decoder))
	HandleFunc("POST", strings.Split("/order", "?")[0], wraporder(ctx, decoder))
	HandleFunc("GET", strings.Split("/order/{uuid}", "?")[0], wraporderStatus(ctx, decoder))
	HandleFunc("GET", strings.Split("/wikibook?page={page}&size={size}&language={language}", "?")[0], wraplistWikibook(ctx, decoder))
	HandleFunc("GET", strings.Split("/wikibook/{uuid}", "?")[0], wrapgetWikibook(ctx, decoder))
	HandleFunc("GET", strings.Split("/wikibook/{uuid}/download", "?")[0], wrapdownloadWikibook(ctx, decoder))

	http.Handle("/", &Router{r: _router})
	log.Printf("HTTP: 0.0.0.0:%s\n", port)
	return http.ListenAndServe(":"+port, nil)
}

func wrapstatus(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeStatusRequest(r)
		if err != nil {
			log.Errorf("GET /status: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*Void)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := statusHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("GET /status: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("GET /status: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}

func wrapcomplete(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeCompleteRequest(r)
		if err != nil {
			log.Errorf("POST /complete: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*CompleteRequest)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := completeHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("POST /complete: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("POST /complete: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}

func wraporder(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeOrderRequest(r)
		if err != nil {
			log.Errorf("POST /order: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*OrderRequest)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := orderHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("POST /order: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("POST /order: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}

func wraporderStatus(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeOrderStatusRequest(r)
		if err != nil {
			log.Errorf("GET /order/{uuid}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*OrderStatusRequest)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := orderStatusHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("GET /order/{uuid}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("GET /order/{uuid}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}

func wraplistWikibook(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeListWikibookRequest(r)
		if err != nil {
			log.Errorf("GET /wikibook?page={page}&size={size}&language={language}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*ListWikibookRequest)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := listWikibookHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("GET /wikibook?page={page}&size={size}&language={language}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("GET /wikibook?page={page}&size={size}&language={language}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}

func wrapgetWikibook(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeGetWikibookRequest(r)
		if err != nil {
			log.Errorf("GET /wikibook/{uuid}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*GetWikibookRequest)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := getWikibookHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("GET /wikibook/{uuid}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("GET /wikibook/{uuid}: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}

func wrapdownloadWikibook(ctx context.Context, decoder httpDecoder) func(w http.ResponseWriter, r *http.Request) {

	f := func(w http.ResponseWriter, r *http.Request) {
		i, err := decoder.DecodeDownloadWikibookRequest(r)
		if err != nil {
			log.Errorf("GET /wikibook/{uuid}/download: %s\n", err)
			w.WriteHeader(500)
			return
		}

		req := i.(*DownloadWikibookRequest)

		ctx = context.WithValue(ctx, "w", w)
		ctx = context.WithValue(ctx, "r", r)
		resp, err := downloadWikibookHandler(ctx, req)
		if err == nil && resp == nil {
			// Nothing to do here
			return
		}

		if err != nil {
			log.Errorf("GET /wikibook/{uuid}/download: %s\n", err)
			w.WriteHeader(500)
			return
		}

		data, err := json.Marshal(resp)
		if err != nil {
			log.Errorf("GET /wikibook/{uuid}/download: %s\n", err)
			w.WriteHeader(500)
			return
		}

		w.Write(data)
	}

	return f
}
